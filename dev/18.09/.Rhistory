taylor.diagrams[[ts]] <- TaylorDiagram(mod.dat, obs = "obs", mod = "mod", group = "model",key.title = "Method", key.pos = "right", normalise=TRUE,main=NULL)
dev.off()
}
return(taylor.diagrams)
}
plotTaylorDiagrams(bmrk_usecase_3)
!is.null(obj$pred$postp)
!is.null(obj$pred$raw)
plotTaylorDiagrams(bmrk_usecase_3)
obj$pred$postp[[1]]
plotTaylorDiagrams(bmrk_usecase_3)
obj$pred$postp[[1]]
obj$pred$postp[[1]]
View(model.t)
sapply(model.t,class)
plotTaylorDiagrams <- function(bmrk_tspred){
require("openair")
require("Cairo")
browser()
taylor.diagrams <- list()
for(ts in names(bmrk_tspred)){
candidate_objs <- bmrk_tspred[[ts]]$ranked_tspred_objs
obj <- candidate_objs[[1]]
if(!is.null(obj$data$test)) data_test <- obj$data$test[[1]]
else stop("no test data was provided for computation",call. = FALSE)
#taylor diagrams for the transforms predictions of the series
data <- data.frame(obs=na.omit(data_test))
mod.dat <- NULL
for(model in names(candidate_objs)){
obj <- candidate_objs[[model]]
model.t <- try(transform(data,
mod=tryCatch( if(!is.null(obj$pred$postp)) obj$pred$postp[[1]]
else if(!is.null(obj$pred$raw)) obj$pred$raw[[1]] ,
error = function(c) NULL),
model=model),TRUE)
if(class(model.t)=="try-error") next
rbind(mod.dat, model.t) -> mod.dat
mod.dat$model <- as.character(mod.dat$model)
}
file_name <- paste("taylorDiagram_",ts,".pdf",sep="")
CairoPDF(file_name,width=5,height=5)
taylor.diagrams[[ts]] <- TaylorDiagram(mod.dat, obs = "obs", mod = "mod", group = "model",key.title = "Method", key.pos = "right", normalise=TRUE,main=NULL)
dev.off()
}
return(taylor.diagrams)
}
plotTaylorDiagrams(bmrk_usecase_3)
sapply(mod.dat,class)
sapply(mod.dat,class)
plotTaylorDiagrams <- function(bmrk_tspred){
require("openair")
require("Cairo")
browser()
taylor.diagrams <- list()
for(ts in names(bmrk_tspred)){
candidate_objs <- bmrk_tspred[[ts]]$ranked_tspred_objs
obj <- candidate_objs[[1]]
if(!is.null(obj$data$test)) data_test <- obj$data$test[[1]]
else stop("no test data was provided for computation",call. = FALSE)
#taylor diagrams for the transforms predictions of the series
data <- data.frame(obs=na.omit(data_test))
mod.dat <- NULL
for(model in names(candidate_objs)){
obj <- candidate_objs[[model]]
model.t <- try(transform(data,
mod=tryCatch( if(!is.null(obj$pred$postp)) as.numeric(obj$pred$postp[[1]])
else if(!is.null(obj$pred$raw)) as.numeric(obj$pred$raw[[1]]) ,
error = function(c) NULL),
model=model),TRUE)
if(class(model.t)=="try-error") next
rbind(mod.dat, model.t) -> mod.dat
mod.dat$model <- as.character(mod.dat$model)
}
file_name <- paste("taylorDiagram_",ts,".pdf",sep="")
CairoPDF(file_name,width=5,height=5)
taylor.diagrams[[ts]] <- TaylorDiagram(mod.dat, obs = "obs", mod = "mod", group = "model",key.title = "Method", key.pos = "right", normalise=TRUE,main=NULL)
dev.off()
}
return(taylor.diagrams)
}
plotTaylorDiagrams(bmrk_usecase_3)
sapply(mod.dat,class)
plotTaylorDiagrams <- function(bmrk_tspred){
require("openair")
require("Cairo")
taylor.diagrams <- list()
for(ts in names(bmrk_tspred)){
candidate_objs <- bmrk_tspred[[ts]]$ranked_tspred_objs
obj <- candidate_objs[[1]]
if(!is.null(obj$data$test)) data_test <- obj$data$test[[1]]
else stop("no test data was provided for computation",call. = FALSE)
#taylor diagrams for the transforms predictions of the series
data <- data.frame(obs=na.omit(data_test))
mod.dat <- NULL
for(model in names(candidate_objs)){
obj <- candidate_objs[[model]]
model.t <- try(transform(data,
mod=tryCatch( if(!is.null(obj$pred$postp)) as.numeric(obj$pred$postp[[1]])
else if(!is.null(obj$pred$raw)) as.numeric(obj$pred$raw[[1]]) ,
error = function(c) NULL),
model=model),TRUE)
if(class(model.t)=="try-error") next
rbind(mod.dat, model.t) -> mod.dat
mod.dat$model <- as.character(mod.dat$model)
}
file_name <- paste("taylorDiagram_usecase_3",ts,".pdf",sep="")
CairoPDF(file_name,width=5,height=5)
taylor.diagrams[[ts]] <- TaylorDiagram(mod.dat, obs = "obs", mod = "mod", group = "model",key.title = "Method", key.pos = "right", normalise=TRUE,main=NULL)
dev.off()
}
return(taylor.diagrams)
}
plotTaylorDiagrams(bmrk_usecase_3)
plotTaylorDiagrams <- function(bmrk_tspred){
require("openair")
require("Cairo")
taylor.diagrams <- list()
for(ts in names(bmrk_tspred)){
candidate_objs <- bmrk_tspred[[ts]]$ranked_tspred_objs
obj <- candidate_objs[[1]]
if(!is.null(obj$data$test)) data_test <- obj$data$test[[1]]
else stop("no test data was provided for computation",call. = FALSE)
#taylor diagrams for the transforms predictions of the series
data <- data.frame(obs=na.omit(data_test))
mod.dat <- NULL
for(model in names(candidate_objs)){
obj <- candidate_objs[[model]]
model.t <- try(transform(data,
mod=tryCatch( if(!is.null(obj$pred$postp)) as.numeric(obj$pred$postp[[1]])
else if(!is.null(obj$pred$raw)) as.numeric(obj$pred$raw[[1]]) ,
error = function(c) NULL),
model=model),TRUE)
if(class(model.t)=="try-error") next
rbind(mod.dat, model.t) -> mod.dat
mod.dat$model <- as.character(mod.dat$model)
}
file_name <- paste("taylorDiagram_usecase_3_",ts,".pdf",sep="")
CairoPDF(file_name,width=5,height=5)
taylor.diagrams[[ts]] <- TaylorDiagram(mod.dat, obs = "obs", mod = "mod", group = "model",key.title = "Method", key.pos = "right", normalise=TRUE,main=NULL)
dev.off()
}
return(taylor.diagrams)
}
plotTaylorDiagrams(bmrk_usecase_3)
boxplot_usecase_3 <- ggplot(transf_errors, aes(x=proc, y=MSE, fill=model)) +
geom_boxplot() +
scale_fill_manual(values=c("#007FFF", "#009000"))+
labs(x="Method",
y="MSE errors",
fill="Normalization")+
theme_bw()
print(boxplot_usecase_3)
summary_data <- summarySE(transf_errors, measurevar="MSE", groupvars=c("norm","proc","model"))
pd <- position_dodge(0.1) # move them .05 to the left and right
lineplot_usecase_3 <- ggplot(summary_data, aes(x=proc, y=MSE, colour=norm, group=model)) +
geom_errorbar(aes(ymin=MSE-se, ymax=MSE+se), colour="black", width=.1, position=pd) +
scale_colour_manual(values=c("#007FFF", "#009000"))+
geom_line(position=pd) +
geom_point(position=pd, size=3)+
labs(x="Method",
y="MSE errors",
fill="Normalization")+
theme_bw()
print(lineplot_usecase_3)
loadlibrary("ggplot2")
loadlibrary("scales")
loadlibrary("Cairo")
loadlibrary("ggthemes")
theme_set(theme_tufte())  # from ggthemes
font.size <- 24
pdf.width <- 5.5
pdf.height <- 3.5
#=====Use Case 2 Results:=====
load("bmrk_usecase_2.RData")
#=======Transforms:======
transf_errors <- data.frame()
for(ts_name in names(bmrk_usecase_2)){
ts <- bmrk_usecase_2[[ts_name]]
specs <- as.character(ts[["rank"]]$tspred_id)
mses <- ts[["rank"]]$MSE
specs <- t(sapply(strsplit(specs, "-"),function(ts) if(length(ts)<3) c("None",ts) else ts))[,1:2]
specs <- data.frame(specs,stringsAsFactors = FALSE)
names(specs) <- c("proc","norm")
transf_errors <- rbind(transf_errors,cbind(ts=ts_name,specs,MSE=mses))
}
transf_errors_tmp <- transf_errors[!(transf_errors$proc=="PCT"&transf_errors$norm=="MinMax"&transf_errors$ts=="V1"),]
summary_data <- summarySE(transf_errors_tmp, measurevar="MSE", groupvars=c("norm","proc"))
summary_data <- summary_data[order(summary_data$MSE),]
pd <- position_dodge(0.1) # move them .05 to the left and right
lineplot_usecase_2 <- ggplot(summary_data, aes(x=proc, y=MSE, colour=norm, group=norm)) +
geom_errorbar(aes(ymin=MSE-se, ymax=MSE+se), colour="black", width=.1, position=pd) +
scale_colour_manual(values=c("#007FFF", "#009000"))+
geom_line(position=pd) +
geom_point(position=pd, size=3)+
labs(x="Method",
y="MSE errors",
colour="Normalization")+
theme_bw()
print(lineplot_usecase_2)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
conf.interval=.95, .drop=TRUE) {
library(plyr)
# New version of length which can handle NA's: if na.rm==T, don't count them
length2 <- function (x, na.rm=FALSE) {
if (na.rm) sum(!is.na(x))
else       length(x)
}
# This does the summary. For each group's data frame, return a vector with
# N, mean, and sd
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col) {
c(N    = length2(xx[[col]], na.rm=na.rm),
mean = mean   (xx[[col]], na.rm=na.rm),
sd   = sd     (xx[[col]], na.rm=na.rm)
)
},
measurevar
)
# Rename the "mean" column
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
# Confidence interval multiplier for standard error
# Calculate t-statistic for confidence interval:
# e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
ciMult <- qt(conf.interval/2 + .5, datac$N-1)
datac$ci <- datac$se * ciMult
return(datac)
}
summary_data <- summarySE(transf_errors_tmp, measurevar="MSE", groupvars=c("norm","proc"))
summary_data <- summary_data[order(summary_data$MSE),]
pd <- position_dodge(0.1) # move them .05 to the left and right
lineplot_usecase_2 <- ggplot(summary_data, aes(x=proc, y=MSE, colour=norm, group=norm)) +
geom_errorbar(aes(ymin=MSE-se, ymax=MSE+se), colour="black", width=.1, position=pd) +
scale_colour_manual(values=c("#007FFF", "#009000"))+
geom_line(position=pd) +
geom_point(position=pd, size=3)+
labs(x="Method",
y="MSE errors",
colour="Normalization")+
theme_bw()
print(lineplot_usecase_2)
lineplot_usecase_2 <- ggplot(summary_data, aes(x=reorder(proc, -MSE), y=MSE, colour=norm, group=norm)) +
geom_errorbar(aes(ymin=MSE-se, ymax=MSE+se), colour="black", width=.1, position=pd) +
scale_colour_manual(values=c("#007FFF", "#009000"))+
geom_line(position=pd) +
geom_point(position=pd, size=3)+
labs(x="Method",
y="MSE errors",
colour="Normalization")+
theme_bw()
print(lineplot_usecase_2)
lineplot_usecase_2 <- ggplot(summary_data, aes(x=reorder(proc, MSE), y=MSE, colour=norm, group=norm)) +
geom_errorbar(aes(ymin=MSE-se, ymax=MSE+se), colour="black", width=.1, position=pd) +
scale_colour_manual(values=c("#007FFF", "#009000"))+
geom_line(position=pd) +
geom_point(position=pd, size=3)+
labs(x="Method",
y="MSE errors",
colour="Normalization")+
theme_bw()
print(lineplot_usecase_2)
lineplot_usecase_2 <- ggplot(summary_data, aes(x=reorder(proc, -MSE), y=MSE, colour=norm, group=norm)) +
geom_errorbar(aes(ymin=MSE-se, ymax=MSE+se), colour="black", width=.1, position=pd) +
scale_colour_manual(values=c("#007FFF", "#009000"))+
geom_line(position=pd) +
geom_point(position=pd, size=3)+
labs(x="Method",
y="MSE errors",
colour="Normalization")+
theme_bw()
print(lineplot_usecase_2)
summary_data <- summarySE(transf_errors_tmp, measurevar="MSE", groupvars=c("norm","proc"))
pd <- position_dodge(0.1) # move them .05 to the left and right
lineplot_usecase_2 <- ggplot(summary_data, aes(x=reorder(proc, -MSE), y=MSE, colour=norm, group=norm)) +
geom_errorbar(aes(ymin=MSE-se, ymax=MSE+se), colour="black", width=.1, position=pd) +
scale_colour_manual(values=c("#007FFF", "#009000"))+
geom_line(position=pd) +
geom_point(position=pd, size=3)+
labs(x="Method",
y="MSE errors",
colour="Normalization")+
theme_bw()
print(lineplot_usecase_2)
boxplot_usecase_2 <- ggplot(transf_errors_tmp, aes(x=reorder(proc, -MSE), y=MSE, fill=norm)) +
geom_boxplot() +
scale_fill_manual(values=c("#007FFF", "#009000"))+
labs(x="Method",
y="MSE errors",
fill="Normalization")+
theme_bw()
print(boxplot_usecase_2)
ggsave("boxplot_usecase_2.pdf", plot = boxplot_usecase_2, width = pdf.width, height = pdf.height)
lineplot_usecase_2 <- ggplot(summary_data, aes(x=reorder(proc, -MSE), y=MSE, colour=norm, group=norm)) +
geom_errorbar(aes(ymin=MSE-se, ymax=MSE+se), colour="black", width=.1, position=pd) +
scale_colour_manual(values=c("#007FFF", "#009000"))+
geom_line(position=pd) +
geom_point(position=pd, size=3)+
labs(x="Method",
y="MSE errors",
colour="Normalization")+
theme_bw()
print(lineplot_usecase_2)
ggsave("lineplot_usecase_2.pdf", plot = lineplot_usecase_2, width = pdf.width, height = pdf.height)
loadlibrary("ggplot2")
loadlibrary("scales")
loadlibrary("Cairo")
loadlibrary("ggthemes")
theme_set(theme_tufte())  # from ggthemes
font.size <- 24
pdf.width <- 5.5
pdf.height <- 3.5
#=====Use Case 1 Results:=====
load("bmrk_usecase_1.RData")
hiperpar <- data.frame()
for(ts in names(bmrk_usecase_1))
hiperpar <- rbind(hiperpar,bmrk_usecase_1[[ts]][1,c("size_lyr_1","size_lyr_2","learnFuncParams","maxit")])
rownames(hiperpar) <- names(bmrk_usecase_1)
View(hiperpar)
View(tspred_1_eval_pipe)
View(tspred_an_nnet_results)
generate_candidate_tspred <- function(candidate,data,test_len=20,prep_test=TRUE,onestep=FALSE,eval_fitness=FALSE){
lyr1 <- candidate$size_lyr_1
lyr2 <- candidate$size_lyr_2
if(is.na(lyr2)) lyr2 <- NULL
decay <- candidate$learnFuncParams
its <- candidate$maxit
window <- lyr1+1
#======================== MLP ========================
tspred_mlp <- tspred(
subsetting=subsetting(test_len=test_len),
modeling=MLP(size=c(lyr1,lyr2),
train_par=list(learnFuncParams=c(decay),
maxit=its),
sw=SW(window_len=window),
proc=list(MM=MinMax(byRow=TRUE))),
evaluating=list(MSE=MSE())
)
#========================================================
invisible(capture.output(tspred_candidate <- workflow(tspred_mlp,data=data,prep_test=prep_test,onestep=onestep,eval_fitness=eval_fitness)))
return(tspred_candidate)
}
data("CATS","CATS.cont")
#========Settings:========
data <- rbind(CATS,CATS.cont)
loadlibrary("TSPred")
data("CATS","CATS.cont")
#========Settings:========
data <- rbind(CATS,CATS.cont)
generate_candidate_tspred <- function(candidate,data,test_len=20,prep_test=TRUE,onestep=FALSE,eval_fitness=FALSE){
lyr1 <- candidate$size_lyr_1
lyr2 <- candidate$size_lyr_2
if(is.na(lyr2)) lyr2 <- NULL
decay <- candidate$learnFuncParams
its <- candidate$maxit
window <- lyr1+1
#======================== MLP ========================
tspred_mlp <- tspred(
subsetting=subsetting(test_len=test_len),
modeling=MLP(size=c(lyr1,lyr2),
train_par=list(learnFuncParams=c(decay),
maxit=its),
sw=SW(window_len=window),
proc=list(MM=MinMax(byRow=TRUE))),
evaluating=list(MSE=MSE())
)
#========================================================
invisible(capture.output(tspred_candidate <- workflow(tspred_mlp,data=data,prep_test=prep_test,onestep=onestep,eval_fitness=eval_fitness)))
return(tspred_candidate)
}
mse_errors <- function(hiperpar,data){
bst_errors <- data.frame()
for(ts in names(data)){
obj <- generate_candidate_tspred(hiperpar[ts,],data[ts],...)
bst_errors <- rbind(bst_errors,MSE=obj$eval$pred$MSE[[ts]])
}
rownames(bst_errors) <- names(bmrk_usecase_1)
names(bst_errors) <- "MSE"
return(bst_errors)
}
bst_errors <- mse_errors(hiperpar,data)
mse_errors <- function(hiperpar,data){
bst_errors <- data.frame()
for(ts in names(data)){
obj <- generate_candidate_tspred(hiperpar[ts,],data[ts])
bst_errors <- rbind(bst_errors,MSE=obj$eval$pred$MSE[[ts]])
}
rownames(bst_errors) <- names(bmrk_usecase_1)
names(bst_errors) <- "MSE"
return(bst_errors)
}
bst_errors <- mse_errors(hiperpar,data)
View(bst_errors)
mse_errors <- function(hiperpar,data){
bst_errors <- data.frame()
for(ts in names(data)){
browser()
obj <- generate_candidate_tspred(hiperpar[ts,],data[ts])
bst_errors <- rbind(bst_errors,MSE=obj$eval$pred$MSE[[ts]])
}
rownames(bst_errors) <- names(bmrk_usecase_1)
names(bst_errors) <- "MSE"
return(bst_errors)
}
bst_errors <- mse_errors(hiperpar,data)
hiperpar[ts,]
data[ts]
View(obj)
obj$eval$pred$MSE[[ts]]
View(bst_errors)
hiperpar[ts,]
View(obj)
View(bst_errors)
n_ts <- length(bmrk_usecase_1)
MSE <- bst_errors$MSE
cats_errors_uc1 <- cbind( E1 = mean(MSE), E2 = mean(head(MSE,n_ts-1)) )
View(cats_errors_uc1)
n_ts <- length(data)
MSE <- bst_errors$MSE
cats_errors_uc1 <- cbind( E1 = mean(MSE), E2 = mean(head(MSE,n_ts-1)) )
View(cats_errors_uc1)
generate_arma_tspred <- function(data,test_len=20,prep_test=FALSE,onestep=FALSE,eval_fitness=FALSE){
#======================== ARMA ========================
tspred_mlp <- tspred(
subsetting=subsetting(test_len=test_len),
modeling=ARIMA(train_par=list(max.d=0, max.D=0, stationary=TRUE)),
evaluating=list(MSE=MSE())
)
#========================================================
invisible(capture.output(tspred_candidate <- workflow(tspred_mlp,data=data,prep_test=prep_test,onestep=onestep,eval_fitness=eval_fitness)))
return(tspred_candidate)
}
mse_errors <- function(data){
bst_errors <- data.frame()
for(ts in names(data)){
obj <- generate_arma_tspred(data[ts])
bst_errors <- rbind(bst_errors,MSE=obj$eval$pred$MSE[[ts]])
}
rownames(bst_errors) <- names(bmrk_usecase_1)
names(bst_errors) <- "MSE"
return(bst_errors)
}
bst_errors <- mse_errors(data)
source('~/GitHub/TSPred/dev/18.09/evaluating_subclasses.r')
mse_errors <- function(data){
bst_errors <- data.frame()
for(ts in names(data)){
obj <- generate_arma_tspred(data[ts])
bst_errors <- rbind(bst_errors,MSE=obj$eval$pred$MSE[[ts]])
}
rownames(bst_errors) <- names(bmrk_usecase_1)
names(bst_errors) <- "MSE"
return(bst_errors)
}
bst_errors <- mse_errors(data)
View(bst_errors)
View(bst_errors)
n_ts <- length(data)
MSE <- bst_errors$MSE
cats_errors_arma <- cbind( E1 = mean(MSE), E2 = mean(head(MSE,n_ts-1)) )
View(cats_errors_arma)
generate_arma_tspred <- function(data,test_len=20,prep_test=FALSE,onestep=FALSE,eval_fitness=FALSE){
#======================== ARMA ========================
tspred_mlp <- tspred(
subsetting=subsetting(test_len=test_len),
modeling=ARIMA(), #train_par=list(max.d=0, max.D=0, stationary=TRUE)
evaluating=list(MSE=MSE())
)
#========================================================
invisible(capture.output(tspred_candidate <- workflow(tspred_mlp,data=data,prep_test=prep_test,onestep=onestep,eval_fitness=eval_fitness)))
return(tspred_candidate)
}
mse_errors <- function(data){
bst_errors <- data.frame()
for(ts in names(data)){
obj <- generate_arma_tspred(data[ts])
bst_errors <- rbind(bst_errors,MSE=obj$eval$pred$MSE[[ts]])
}
rownames(bst_errors) <- names(data)
names(bst_errors) <- "MSE"
return(bst_errors)
}
bst_errors <- mse_errors(data)
n_ts <- length(data)
MSE <- bst_errors$MSE
cats_errors_arma <- cbind( E1 = mean(MSE), E2 = mean(head(MSE,n_ts-1)) )
source('~/GitHub/TSPred/dev/18.09/evaluating_subclasses.r')
generate_arma_tspred <- function(data,test_len=20,prep_test=FALSE,onestep=FALSE,eval_fitness=FALSE){
#======================== ARMA ========================
tspred_mlp <- tspred(
subsetting=subsetting(test_len=test_len),
modeling=ARIMA(), #train_par=list(max.d=0, max.D=0, stationary=TRUE)
evaluating=list(MSE=MSE())
)
#========================================================
invisible(capture.output(tspred_candidate <- workflow(tspred_mlp,data=data,prep_test=prep_test,onestep=onestep,eval_fitness=eval_fitness)))
return(tspred_candidate)
}
mse_errors <- function(data){
bst_errors <- data.frame()
for(ts in names(data)){
obj <- generate_arma_tspred(data[ts])
bst_errors <- rbind(bst_errors,MSE=obj$eval$pred$MSE[[ts]])
}
rownames(bst_errors) <- names(data)
names(bst_errors) <- "MSE"
return(bst_errors)
}
bst_errors <- mse_errors(data)
n_ts <- length(data)
MSE_errors <- bst_errors$MSE
cats_errors_arma <- cbind( E1 = mean(MSE_errors), E2 = mean(head(MSE_errors,n_ts-1)) )
View(cats_errors_arma)
